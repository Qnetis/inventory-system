// frontend/src/components/Records/AdvancedFilters.tsx
/* eslint-disable @typescript-eslint/no-explicit-any */

import React, { useState, useEffect } from 'react';
import {
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  Button,
  Box,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TextField,
  Typography,
  Divider,
  IconButton,
} from '@mui/material';
import {
  Add as AddIcon,
  Delete as DeleteIcon,
} from '@mui/icons-material';

interface FilterCondition {
  id: string;
  field: string;
  operator: string;
  value: any;
  fieldType?: string;
}

interface AdvancedFiltersProps {
  open: boolean;
  onClose: () => void;
  fields: any[];
  onApplyFilters: (filters: FilterCondition[]) => void;
  initialFilters?: FilterCondition[];
}

// –û–ø–µ—Ä–∞—Ç–æ—Ä—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –ø–æ–ª–µ–π
const getOperatorsForFieldType = (fieldType: string) => {
  switch (fieldType) {
    case 'text':
    case 'string':
    case 'TEXT':
      return [
        { value: 'contains', label: '–°–æ–¥–µ—Ä–∂–∏—Ç' },
        { value: 'equals', label: '–†–∞–≤–Ω–æ' },
        { value: 'startsWith', label: '–ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å' },
        { value: 'endsWith', label: '–ó–∞–∫–∞–Ω—á–∏–≤–∞–µ—Ç—Å—è –Ω–∞' },
        { value: 'notEquals', label: '–ù–µ —Ä–∞–≤–Ω–æ' },
      ];
    case 'number':
    case 'money':
    case 'NUMBER':
    case 'MONEY':
      return [
        { value: 'equals', label: '–†–∞–≤–Ω–æ' },
        { value: 'notEquals', label: '–ù–µ —Ä–∞–≤–Ω–æ' },
        { value: 'greater', label: '–ë–æ–ª—å—à–µ' },
        { value: 'less', label: '–ú–µ–Ω—å—à–µ' },
        { value: 'greaterOrEqual', label: '–ë–æ–ª—å—à–µ –∏–ª–∏ —Ä–∞–≤–Ω–æ' },
        { value: 'lessOrEqual', label: '–ú–µ–Ω—å—à–µ –∏–ª–∏ —Ä–∞–≤–Ω–æ' },
        { value: 'between', label: '–ú–µ–∂–¥—É' },
      ];
    case 'checkbox':
    case 'boolean':
    case 'CHECKBOX':
      return [
        { value: 'equals', label: '–†–∞–≤–Ω–æ' },
        { value: 'notEquals', label: '–ù–µ —Ä–∞–≤–Ω–æ' },
      ];
    case 'select':
    case 'SELECT':
      return [
        { value: 'equals', label: '–†–∞–≤–Ω–æ' },
        { value: 'notEquals', label: '–ù–µ —Ä–∞–≤–Ω–æ' },
        { value: 'in', label: '–û–¥–∏–Ω –∏–∑' },
        { value: 'notIn', label: '–ù–µ –æ–¥–∏–Ω –∏–∑' },
      ];
    case 'date':
    case 'DATE':
      return [
        { value: 'equals', label: '–†–∞–≤–Ω–æ' },
        { value: 'notEquals', label: '–ù–µ —Ä–∞–≤–Ω–æ' },
        { value: 'after', label: '–ü–æ—Å–ª–µ' },
        { value: 'before', label: '–î–æ' },
        { value: 'between', label: '–ú–µ–∂–¥—É' },
      ];
    default:
      return [
        { value: 'contains', label: '–°–æ–¥–µ—Ä–∂–∏—Ç' },
        { value: 'equals', label: '–†–∞–≤–Ω–æ' },
      ];
  }
};

// –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª—è
const getFieldValue = (record: any, fieldName: string) => {
  console.log('üîç getFieldValue - –ü–æ–∏—Å–∫ –ø–æ–ª—è:', fieldName, '–≤ –∑–∞–ø–∏—Å–∏:', record);
  
  // –°–∏—Å—Ç–µ–º–Ω—ã–µ –ø–æ–ª—è
  if (fieldName === 'barcode') {
    const value = record.barcode;
    console.log('üîç –°–∏—Å—Ç–µ–º–Ω–æ–µ –ø–æ–ª–µ barcode:', value);
    return value;
  }
  
  if (fieldName === 'name') {
    const value = record.name;
    console.log('üîç –°–∏—Å—Ç–µ–º–Ω–æ–µ –ø–æ–ª–µ name:', value);
    return value;
  }
  
  if (fieldName === 'createdAt') {
    const value = record.createdAt;
    console.log('üîç –°–∏—Å—Ç–µ–º–Ω–æ–µ –ø–æ–ª–µ createdAt:', value);
    return value;
  }

  // –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –ò—â–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–µ –ø–æ–ª—è –≤ dynamicData
  if (record.dynamicData && record.dynamicData[fieldName]) {
    const value = record.dynamicData[fieldName];
    console.log('üîç –ù–∞–π–¥–µ–Ω–æ –≤ dynamicData:', fieldName, '=', value);
    return value;
  }

  console.log('‚ùå –ü–æ–ª–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ:', fieldName);
  return undefined;
};

// –§—É–Ω–∫—Ü–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —É—Å–ª–æ–≤–∏—è —Ñ–∏–ª—å—Ç—Ä–∞
const applyFilterCondition = (fieldValue: any, filter: FilterCondition) => {
  const { operator, value, fieldType } = filter;
  
  console.log('üîç applyFilterCondition:', {
    fieldValue,
    operator,
    value,
    fieldType
  });

  // –û–±—Ä–∞–±–æ—Ç–∫–∞ undefined/null –∑–Ω–∞—á–µ–Ω–∏–π
  if (fieldValue === undefined || fieldValue === null) {
    // –ï—Å–ª–∏ –ø–æ–ª–µ –ø—É—Å—Ç–æ–µ, —Ç–æ —Ç–æ–ª—å–∫–æ —É—Å–ª–æ–≤–∏—è "equals" –∫ –ø—É—Å—Ç–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é –±—É–¥—É—Ç true
    return operator === 'equals' && (value === '' || value === null || value === undefined);
  }

  // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
  let normalizedFieldValue = fieldValue;
  let normalizedFilterValue = value;

  if (fieldType === 'number' || fieldType === 'money' || fieldType === 'NUMBER' || fieldType === 'MONEY') {
    normalizedFieldValue = parseFloat(fieldValue) || 0;
    normalizedFilterValue = parseFloat(value) || 0;
  } else if (fieldType === 'checkbox' || fieldType === 'boolean' || fieldType === 'CHECKBOX') {
    normalizedFieldValue = Boolean(fieldValue);
    normalizedFilterValue = Boolean(value);
  } else if (typeof fieldValue === 'string') {
    normalizedFieldValue = fieldValue.toLowerCase();
    normalizedFilterValue = String(value).toLowerCase();
  }

  switch (operator) {
    case 'equals': {
      const result = normalizedFieldValue === normalizedFilterValue;
      console.log('üîç equals:', normalizedFieldValue, '===', normalizedFilterValue, '=', result);
      return result;
    }
    case 'notEquals':
      return normalizedFieldValue !== normalizedFilterValue;
    case 'contains':
      return String(normalizedFieldValue).includes(String(normalizedFilterValue));
    case 'startsWith':
      return String(normalizedFieldValue).startsWith(String(normalizedFilterValue));
    case 'endsWith':
      return String(normalizedFieldValue).endsWith(String(normalizedFilterValue));
    case 'greater':
      return normalizedFieldValue > normalizedFilterValue;
    case 'less':
      return normalizedFieldValue < normalizedFilterValue;
    case 'greaterOrEqual':
      return normalizedFieldValue >= normalizedFilterValue;
    case 'lessOrEqual':
      return normalizedFieldValue <= normalizedFilterValue;
    case 'between': {
      const [min, max] = Array.isArray(value) ? value : [value.min, value.max];
      return normalizedFieldValue >= parseFloat(min) && normalizedFieldValue <= parseFloat(max);
    }
    case 'in': {
      const inValues = Array.isArray(value) ? value : [value];
      return inValues.includes(normalizedFieldValue);
    }
    case 'notIn': {
      const notInValues = Array.isArray(value) ? value : [value];
      return !notInValues.includes(normalizedFieldValue);
    }
    case 'after':
      return new Date(fieldValue) > new Date(value);
    case 'before':
      return new Date(fieldValue) < new Date(value);
    default:
      return true;
  }
};

// –ò–°–ü–†–ê–í–õ–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ –¥–∞–Ω–Ω—ã–º
export const applyFiltersToData = (data: any[], filters: FilterCondition[]) => {
  if (!filters.length) {
    console.log('üîç –ù–µ—Ç —Ñ–∏–ª—å—Ç—Ä–æ–≤, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ');
    return data;
  }

  console.log('üîç –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã:', filters);
  console.log('üîç –ö –¥–∞–Ω–Ω—ã–º:', data.slice(0, 2)); // –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 2 –∑–∞–ø–∏—Å–∏ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏

  const filtered = data.filter(record => {
    return filters.every(filter => {
      const fieldValue = getFieldValue(record, filter.field);
      const result = applyFilterCondition(fieldValue, filter);
      console.log('üîç –§–∏–ª—å—Ç—Ä', filter.field, ':', fieldValue, '->', result);
      return result;
    });
  });

  console.log('üîç –†–µ–∑—É–ª—å—Ç–∞—Ç —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏:', filtered.length, '–∏–∑', data.length);
  return filtered;
};

export const AdvancedFilters: React.FC<AdvancedFiltersProps> = ({
  open,
  onClose,
  fields,
  onApplyFilters,
  initialFilters = [],
}) => {
  const [filters, setFilters] = useState<FilterCondition[]>([]);

  useEffect(() => {
    if (open) {
      setFilters(initialFilters.length > 0 ? [...initialFilters] : [createEmptyFilter()]);
    }
  }, [open, initialFilters]);

  const createEmptyFilter = (): FilterCondition => ({
    id: Math.random().toString(36).substr(2, 9),
    field: '',
    operator: 'contains',
    value: '',
    fieldType: 'text',
  });

  const addFilter = () => {
    setFilters([...filters, createEmptyFilter()]);
  };

  const removeFilter = (id: string) => {
    setFilters(filters.filter(f => f.id !== id));
  };

  const updateFilter = (id: string, updates: Partial<FilterCondition>) => {
    setFilters(filters.map(f => 
      f.id === id ? { ...f, ...updates } : f
    ));
  };

  const handleFieldChange = (id: string, fieldName: string) => {
    // –ù–∞—Ö–æ–¥–∏–º —Ç–∏–ø –ø–æ–ª—è
    let fieldType = 'text';
    
    if (fieldName === 'barcode' || fieldName === 'name') {
      fieldType = 'text';
    } else if (fieldName === 'createdAt') {
      fieldType = 'date';
    } else {
      // –ò—â–µ–º —Å—Ä–µ–¥–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –ø–æ–ª–µ–π
      const field = fields.find(f => {
        const fieldId = f.id?.toString();
        return fieldId === fieldName;
      });
      
      if (field) {
        const fieldData = field.attributes || field;
        fieldType = fieldData.fieldType?.toLowerCase() || 'text';
      }
    }
    
    console.log('üîç handleFieldChange:', fieldName, 'type:', fieldType);
    
    updateFilter(id, {
      field: fieldName,
      fieldType: fieldType,
      operator: 'contains',
      value: '',
    });
  };

  const handleApply = () => {
    const validFilters = filters.filter(f => f.field && f.value !== '');
    console.log('üîç –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã:', validFilters);
    onApplyFilters(validFilters);
    onClose();
  };

  const handleClear = () => {
    setFilters([createEmptyFilter()]);
    onApplyFilters([]);
  };

  const renderValueInput = (filter: FilterCondition) => {
    const field = fields.find(f => f.id?.toString() === filter.field);
    const fieldData = field?.attributes || field;
    
    if (filter.operator === 'between') {
      return (
        <Box sx={{ display: 'flex', gap: 1, alignItems: 'center' }}>
          <TextField
            size="small"
            label="–û—Ç"
            type={filter.fieldType === 'number' || filter.fieldType === 'money' || 
                  filter.fieldType === 'NUMBER' || filter.fieldType === 'MONEY' ? 'number' : 'text'}
            value={filter.value?.min || ''}
            onChange={(e) => updateFilter(filter.id, {
              value: { ...filter.value, min: e.target.value }
            })}
          />
          <Typography>-</Typography>
          <TextField
            size="small"
            label="–î–æ"
            type={filter.fieldType === 'number' || filter.fieldType === 'money' ||
                  filter.fieldType === 'NUMBER' || filter.fieldType === 'MONEY' ? 'number' : 'text'}
            value={filter.value?.max || ''}
            onChange={(e) => updateFilter(filter.id, {
              value: { ...filter.value, max: e.target.value }
            })}
          />
        </Box>
      );
    }

    if (filter.fieldType === 'select' || filter.fieldType === 'SELECT') {
      return (
        <FormControl size="small" sx={{ minWidth: 150 }}>
          <InputLabel>–ó–Ω–∞—á–µ–Ω–∏–µ</InputLabel>
          <Select
            value={filter.value}
            onChange={(e) => updateFilter(filter.id, { value: e.target.value })}
            label="–ó–Ω–∞—á–µ–Ω–∏–µ"
          >
            {fieldData?.options?.map((option: string) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </Select>
        </FormControl>
      );
    }

    if (filter.fieldType === 'checkbox' || filter.fieldType === 'CHECKBOX') {
      return (
        <FormControl size="small" sx={{ minWidth: 150 }}>
          <InputLabel>–ó–Ω–∞—á–µ–Ω–∏–µ</InputLabel>
          <Select
            value={filter.value === true ? 'true' : filter.value === false ? 'false' : ''}
            onChange={(e) => updateFilter(filter.id, { value: e.target.value === 'true' })}
            label="–ó–Ω–∞—á–µ–Ω–∏–µ"
          >
            <MenuItem value="true">–î–∞</MenuItem>
            <MenuItem value="false">–ù–µ—Ç</MenuItem>
          </Select>
        </FormControl>
      );
    }

    return (
      <TextField
        size="small"
        label="–ó–Ω–∞—á–µ–Ω–∏–µ"
        sx={{ minWidth: 150 }}
        type={filter.fieldType === 'number' || filter.fieldType === 'money' || 
              filter.fieldType === 'NUMBER' || filter.fieldType === 'MONEY' ? 'number' : 
              filter.fieldType === 'date' || filter.fieldType === 'DATE' ? 'date' : 'text'}
        value={filter.value}
        onChange={(e) => updateFilter(filter.id, { value: e.target.value })}
        InputLabelProps={filter.fieldType === 'date' || filter.fieldType === 'DATE' ? { shrink: true } : undefined}
      />
    );
  };

  return (
    <Dialog open={open} onClose={onClose} maxWidth="md" fullWidth>
      <DialogTitle>
        –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
      </DialogTitle>
      
      <DialogContent>
        <Box sx={{ py: 2 }}>
          {filters.map((filter, index) => (
            <Box key={filter.id} sx={{ mb: 2 }}>
              {index > 0 && (
                <Typography variant="body2" sx={{ mb: 1, color: 'text.secondary' }}>
                  –ò
                </Typography>
              )}
              
              <Box sx={{ display: 'flex', gap: 2, alignItems: 'center', flexWrap: 'wrap' }}>
                {/* –ü–æ–ª–µ */}
                <FormControl size="small" sx={{ minWidth: 200 }}>
                  <InputLabel>–ü–æ–ª–µ</InputLabel>
                  <Select
                    value={filter.field}
                    onChange={(e) => handleFieldChange(filter.id, e.target.value)}
                    label="–ü–æ–ª–µ"
                  >
                    <MenuItem value="barcode">–®—Ç—Ä–∏—Ö–∫–æ–¥</MenuItem>
                    <MenuItem value="name">–ù–∞–∑–≤–∞–Ω–∏–µ</MenuItem>
                    <MenuItem value="createdAt">–î–∞—Ç–∞ —Å–æ–∑–¥–∞–Ω–∏—è</MenuItem>
                    <Divider />
                    {fields.map(field => {
                      const fieldData = field.attributes || field;
                      const fieldId = field.id?.toString();
                      return (
                        <MenuItem key={field.id} value={fieldId}>
                          {fieldData.name}
                        </MenuItem>
                      );
                    })}
                  </Select>
                </FormControl>

                {/* –û–ø–µ—Ä–∞—Ç–æ—Ä */}
                <FormControl size="small" sx={{ minWidth: 150 }}>
                  <InputLabel>–£—Å–ª–æ–≤–∏–µ</InputLabel>
                  <Select
                    value={filter.operator}
                    onChange={(e) => updateFilter(filter.id, { operator: e.target.value })}
                    label="–£—Å–ª–æ–≤–∏–µ"
                    disabled={!filter.field}
                  >
                    {getOperatorsForFieldType(filter.fieldType || 'text').map(op => (
                      <MenuItem key={op.value} value={op.value}>
                        {op.label}
                      </MenuItem>
                    ))}
                  </Select>
                </FormControl>

                {/* –ó–Ω–∞—á–µ–Ω–∏–µ */}
                {renderValueInput(filter)}

                {/* –ö–Ω–æ–ø–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è */}
                <IconButton
                  size="small"
                  onClick={() => removeFilter(filter.id)}
                  disabled={filters.length === 1}
                >
                  <DeleteIcon />
                </IconButton>
              </Box>
            </Box>
          ))}

          <Button
            startIcon={<AddIcon />}
            onClick={addFilter}
            variant="outlined"
            size="small"
          >
            –î–æ–±–∞–≤–∏—Ç—å —É—Å–ª–æ–≤–∏–µ
          </Button>
        </Box>
      </DialogContent>

      <DialogActions>
        <Button onClick={handleClear}>
          –û—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ
        </Button>
        <Button onClick={onClose}>
          –û—Ç–º–µ–Ω–∞
        </Button>
        <Button onClick={handleApply} variant="contained">
          –ü—Ä–∏–º–µ–Ω–∏—Ç—å
        </Button>
      </DialogActions>
    </Dialog>
  );
};